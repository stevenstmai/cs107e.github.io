#ifndef INTERRUPTS_H
#define INTERRUPTS_H

#include <stdbool.h>
#include <stddef.h>

/*
 * Module to configure interrupts for Raspberry Pi.
 *
 * Author: Philip Levis <pal@cs.stanford.edu>
 * Author: Pat Hanrahan <hanrahan@cs.stanford.edu>
 * Author: Julie Zelenski <zelenski@cs.stanford.edu>
 *
 * Last update:   May 2020
 */

/*
 * `interrupts_init`: Required initialization for interrupts
 *
 * Initialize interrupts and configures to a clean state.
 *
 *    - vector table is copied to destination address 0
 *    - all interrupt sources are disabled
 *    - interrupts are globally disabled
 *
 * This module init should be called once (and only once)
 * before any calls to other functions in the interrupts module.
 * Calling the init function a second time will raise an error.
 * Without more specific initialization semantics and structure,
 * this is the safe approach that avoids having to debug why a
 * source suddenly stopped receiving interrupts after a re-init
 * silently wiped the settings from previous configuration.
 */
void interrupts_init(void);

/*
 * `interrupts_global_enable`
 *
 * Turns on interrupts system-wide. An interrupt generated on
 * an interrupt source that is enabled will call the registered handler.
 */
void interrupts_global_enable(void);

/*
 * `interrupts_global_disable`
 *
 * Turns off interrupts system-wide. No interrupts will be generated.
 * Does not remove registered handlers or disable interrupt sources,
 * only temporarily suspends interrupt generation. Call
 * `interrupts_global_enable` to resume generating interrupts.
 */
void interrupts_global_disable(void);

/*
 * `interrupts_enable_source`
 *
 * Enable a particular interrupt source. The source itself must still
 * be configured to generate interrupts (and global interrupts must be
 * enabled) for a registered handler to be called. The source should be
 * a value from the INTERRUPTS enum below.
 */
void interrupts_enable_source(unsigned int source);

/*
 * `interrupts_disable_source`
 *
 * Disable a particular interrupt source. Interrupts for this source
 * will not trigger a handler and will remain pending (until cleared).
 * The source should be a value from the INTERRUPTS enum below.
 */
void interrupts_disable_source(unsigned int source);


/*
 * `handler_fn_t`
 *
 * This typedef gives a nickname to the type of function pointer used as
 * a handler callback. A handler is registered to an interrupt source. When
 * an interrupt is generated by that source, the handler is called to
 * process it. A handler takes two arguments. The first argument is the
 * value of the interrupted pc and second argument is the client's
 * auxiliary data pointer (can be NULL if not used).
 */
typedef void (*handler_fn_t)(unsigned int, void *);

/*
 * `interrupts_register_handler`
 *
 * Register the handler function for a given interrupt source. Each interrupt
 * source can have one handler: further dispatch should be invoked by
 * the handler itself. Registering a handler does not enable the source:
 * this must be done separately through `interrupts_enable_source`.
 * These are separate because otherwise there can be impossible-to-solve
 * technical challenges such as 
 *   - having an interrupt handled before `interrupts_register_handler` returns,
 *   - handling interrupts that were pending from a different use of the source,
 *   - changing the handler as one part of a larger atomic action. 
 *
 * This function asserts on an attempt to register handler without initializing
 * the interrupts module (i.e. required to call `interrupts_init` first).
 *
 * Valid interrupt sources are basic interrupts and those with entries in
 * the interrupt table in the BCM2835 manual: GPU and other reserved
 * interrupts are invalid.
 *
 * An interrupt source is identified by number. Valid source numbers are
 * listed below in the `interrupt_source` enumeration.
 * The sources we will commonly use are
 *     INTERRUPTS_GPIO3 for gpio interrupts (source shared by all gpios)
 *     INTERRUPTS_BASIC_ARM_TIMER_IRQ  for armtimer interrupts
 *
 * @param source    which interrupt source (see enumeration values below)
 * @param fn        handler function to call when interrupt generated on source
 * @param aux_data  client's data pointer to be passed as second argument
 *                  when calling handler function
 *
 * An assert is raised if `source` is invalid. `aux_data` can be NULL if
 * handler function has no need for auxiliary data. If `fn` is NULL, this
 * removes any handler previously registered for `source`.
 */
void interrupts_register_handler(unsigned int source, handler_fn_t fn, void *aux_data);

/*
 * Enumeration of valid interrupt sources
 *
 * Below are the interrupt sources that this module can enable, disable,
 * and handle. AUX through VC_UART are all IRQs from peripherals. There
 * are 64 peripheral interrupts, but only these ones should be handled by
 * your code -- the datasheet says (BCM2835 Sec 7.5)
 *    "The table has many empty entries. These should not be
 *     enabled as they will interfere with the GPU operation."
 *
 * So there is a peripheral interrupt 0 but you should not handle it.
 *
 * Values with _BASIC_ in them are basic interrupts that are generated
 * from the core itself. Normally, these are a completely separate
 * identifier space of interrupts. Basic interrupt 0 is the ARM_TIMER
 * interrupt, for example. Rather than have two separate sets of functions
 * for peripheral and basic interrupts, we just give them IDs > 64 and
 * then map them to their real values in the code. Using a single
 * identifier space means that we avoid the inevitable bug of someone
 * passing a basic interrupt ID to a peripheral interrupt function and
 * vice versa.
 */
enum interrupt_source {
    INTERRUPTS_SHARED_START    = 29,
    INTERRUPTS_AUX             = 29,
    INTERRUPTS_I2CSPISLV       = 43,
    INTERRUPTS_PWA0            = 45,
    INTERRUPTS_PWA1            = 46,
    INTERRUPTS_CPR             = 47,
    INTERRUPTS_SMI             = 48,
    INTERRUPTS_GPIO0           = 49,
    INTERRUPTS_GPIO1           = 50,
    INTERRUPTS_GPIO2           = 51,
    INTERRUPTS_GPIO3           = 52,
    INTERRUPTS_VC_I2C          = 53,
    INTERRUPTS_VC_SPI          = 54,
    INTERRUPTS_VC_I2SPCM       = 55,
    INTERRUPTS_VC_UART         = 57,
    INTERRUPTS_SHARED_END,

    INTERRUPTS_BASIC_BASE      = 64,
    INTERRUPTS_BASIC_ARM_TIMER_IRQ = INTERRUPTS_BASIC_BASE,
    INTERRUPTS_BASIC_ARM_MAILBOX_IRQ,
    INTERRUPTS_BASIC_ARM_DOORBELL_0_IRQ,
    INTERRUPTS_BASIC_GPU_0_HALTED_IRQ,
    INTERRUPTS_BASIC_GPU_1_HALTED_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_1_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_0_IRQ,
    INTERRUPTS_BASIC_END,
    INTERRUPTS_COUNT,
    INTERRUPTS_NONE = 255,
};


#endif
